s 1 0 11 0 0 0 0 0 11 2:/*
 *
 */

switch()
{
    case    :
        break;
    default:
        break;
}
n 1 0 1 0 0 0 0 0 1 11:#include <>
b 1 7 10 0 0 0 0 0 3 2:/*
 *
 */
e 1 4 7 0 0 0 0 0 3 10:enum class
{
};
t 1 35 56 0 0 26 36 0 21 51:// Example template defs, choose one, maybe augment
template <typename T>
template <typename T, int N>    // Value argument, must be a constant
template <element T>            // Constrained template, C++20
class replace_me    // Replace replace_me with the class name
{
    // Interface functions (a.k.a. methods in some languages)
    public:
        // Constructor should establish invariants (assumptions) for the class
        replace_me() { }
        // Destructor should free all allocated resources
        ~replace_me() { }
        // Other member functions should ensure that the invariants still hold
    
    // Accessible by members of derived classes and friend classes
    protected:
    
    // Implementation (mostly data members)
    // Accessible only by members functions of this class
    private:
};
x 1 27 46 0 0 20 22 0 19 51:// try-catch blocks are rare in well-designed code.
// Use RAII (Resource Allocation Is Initialization) to avoid problems instead.
// Use simple function return codes where possible.  They are more efficient.
// Use exceptions where errors are rare, the caller cannot handle the
// error easily, a return code is not enough information, etc.
try
{
    // Any statement that might throw an exception
}
// Replace replace_me with the exception type
// See <stdexcept> for common exceptions
catch(replace_me & err)
{
    cerr << err.what() << endl;
    // Use this if it's impossible to recover from the exception
    // std::terminate();
    // Use this to rethrow the exception (pass it up to the caller)
    // throw;
}
u 1 29 65 0 0 16 41 0 36 76:/***************************************************************************
 *  Use auto-c2man to generate a man page from this comment
 *
 *  Name:
 *      -
 *
 *  Library:
 *      #include <>
 *      -l
 *
 *  Description:
 *  
 *  Arguments:
 *
 *  Returns:
 *
 *  Examples:
 *
 *  Files:
 *
 *  Environment
 *
 *  See also:
 *
 *  History: 
 *  Date        Name        Modification
 *  2025-10-05  Jason Bacon Begin
 ***************************************************************************/

// Use "type var = value" for optional arguments.
// This is a shorthand for overloading the function.
()

{
    return ;
}
d 1 1 8 0 0 0 0 0 7 2:/*
 *
 */

do
{
}   while ();
f 1 1 8 0 0 0 0 0 7 2:/*
 *
 */

for ( ; ; )
{
}
i 1 1 11 0 0 0 0 0 10 2:/*
 *
 */

if ()
{
}
else
{
}
w 1 60 67 0 0 41 41 0 7 2:/*
 *
 */

while ()
{
}
m 0 0 26 0 1 0 2 0 26 19:#include <iostream>
#include <sysexits.h>

int     usage(char *argv[]);

int     main(int argc,char *argv[])

{
    switch(argc)
    {
        case 1:
            break;
        
        default:
            return usage(argv);
    }
    
    return EX_OK;
}


int     usage(char *argv[])

{
    std::cerr << "Usage: " << argv[0] << std::endl;
    return EX_USAGE;
}a 1 57 106 0 0 55 88 0 49 41:// Replace class_name with the class name
// Replace base_class with the base class from which this is derived
class class_name : public base_class
{
    // Interface functions (a.k.a. methods in some languages)
    public:
        // Constructors should establish invariants (assumptions) for the class
        // Other member functions should ensure that the invariants still hold
        // Default versions of these are automatically generated.
        // However, if the class contains pointers to allocated objects,
        // the default copy and destructor functions may not be correct.
        // Make sure they handle allocated objects correctly.
        // Rule of zero: Define all of these functions or none.
        
        // Constructor with a single argument handles conversions:
        //      class_name object(1);
        //      class_name object { 1 };
        //      class_name object = 1;
        // class_name(int n) {}
        // Default constructor
        // class_name() {}
        // Copy constructor
        // class_name(const class_name &) {}
        // Move constructor
        // class_name(class_name &&) {}
        // Copy assignment
        // class_name & operator=(const class_name &) {}
        // Move assignment
        // class_name & operator=(class_name &&) {}
        // Default destructor
        // ~class_name() {}
        
        // const indicates that func_name() does not modify members,
        // so it can be invoked for const objects
        // override tells the compiler to verify that there is a corresponding
        // virtual function in the base/super class.  Otherwise, a misspelled
        // function name will be assumed to be intentional and valid.
        void    func_name () const override {};
        
        // func_name2() cannot be invoked for const objects
        void    func_name2 () override {};
    
    // Accessible by members of derived classes and friend classes
    protected:
    
    // Implementation (mostly data members)
    // Accessible only by members functions of this class
    private:
};
c 1 3 56 0 0 2 32 0 53 17:// Concrete class
// Replace class_name with the class name
class class_name
{
    // Interface functions (a.k.a. methods in some languages)
    public:
        // Constructors should establish invariants (assumptions) for the class
        // Other member functions should ensure that the invariants still hold
        // Default constructors and assignments are automatically generated.
        // However, if the class contains pointers to allocated objects,
        // the default copy and destructor functions may not be correct.
        // Make sure they handle allocated objects correctly.
        // Rule of zero: Define all of these functions or none.
        
        // Constructor with a single argument handles conversions:
        //      class_name object(1);
        //      class_name object { 1 };
        //      class_name object = 1;
        //      object = 1;
        // class_name(int n) {}
        // Disallow implicit conversions:
        //      class_name object = 1;
        //      object = 1;
        // explicit class_name(int n) {}
        // Default constructor
        // class_name() {}
        // Copy constructor, initialize from a like object
        // class_name(const class_name &) {}
        // Copy assignment, assign from a like object
        // class_name & operator=(const class_name &) {}
        // Move constructor, for returning large objects by reference
        // class_name(class_name &&) {}
        // Move assignment
        //      // move() converts to rvalue reference
        //      y = std::move(x);
        // class_name & operator=(class_name &&) {}
        // Default destructor
        // ~class_name() {}
        
        // const indicates that func_name() does not modify members,
        // so it can be invoked for const objects
        void    func_name () const {}
        
        // func_name2() cannot be invoked for const objects
        void    func_name2 () {}
    
    // Accessible by members of derived classes and friend classes
    protected:
    
    // Implementation (mostly data members)
    // Accessible only by members functions of this class
    private:
};
r 1 53 115 0 0 51 91 0 62 16:// Derived class
// This class implements the representation (data members) and some/all of
// the concrete member functions for the base/super class "base_class".
// There should be multiple derived classes for each base class,
// otherwise the base class serves no purpose.

// Replace class_name with the class name
// Replace base_class with the base class from which this is derived
class class_name : public base_class
{
    // Interface functions (a.k.a. methods in some languages)
    public:
        // Constructors should establish invariants (assumptions) for the class
        // Other member functions should ensure that the invariants still hold
        // Default constructors and assignments are automatically generated.
        // However, if the class contains pointers to allocated objects,
        // the default copy and destructor functions may not be correct.
        // Make sure they handle allocated objects correctly.
        // Rule of zero: Define all of these functions or none.
        
        // Constructor with a single argument handles conversions:
        //      class_name object(1);
        //      class_name object { 1 };
        //      class_name object = 1;
        //      object = 1;
        // class_name(int n) {}
        // Disallow implicit conversions:
        //      class_name object = 1;
        //      object = 1;
        // explicit class_name(int n) {}
        // Default constructor
        // class_name() {}
        // Copy constructor, initialize from a like object
        // class_name(const class_name &) {}
        // Copy assignment, assign from a like object
        // class_name & operator=(const class_name &) {}
        // Move constructor, for returning large objects by reference
        // class_name(class_name &&) {}
        // Move assignment
        //      // move() converts to rvalue reference
        //      y = std::move(x);
        // class_name & operator=(class_name &&) {}
        // Default destructor
        // ~class_name() {}
        
        // const indicates that func_name() does not modify members,
        // so it can be invoked for const objects
        // override tells the compiler to verify that there is a corresponding
        // virtual function in the base/super class.  Otherwise, a misspelled
        // function name will be assumed to be intentional and valid.
        void    func_name () const override {};
        
        // func_name2() cannot be invoked for const objects
        void    func_name2 () override {};
    
    // Accessible by members of derived classes and friend classes
    protected:
    
    // Implementation (mostly data members)
    // Accessible only by members functions of this class
    private:
};
