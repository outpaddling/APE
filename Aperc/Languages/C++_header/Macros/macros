n 1 0 1 0 0 0 0 0 1 11:#include <>
b 1 7 10 0 0 0 0 0 3 2:/*
 *
 */
e 1 4 7 0 0 0 0 0 3 10:enum class
{
};
t 1 35 56 0 0 26 36 0 21 51:// Example template defs, choose one, maybe augment
template <typename T>
template <typename T, int N>    // Value argument, must be a constant
template <element T>            // Constrained template, C++20
class replace_me    // Replace replace_me with the class name
{
    // Interface functions (a.k.a. methods in some languages)
    public:
        // Constructor should establish invariants (assumptions) for the class
        replace_me() { }
        // Destructor should free all allocated resources
        ~replace_me() { }
        // Other member functions should ensure that the invariants still hold
    
    // Accessible by members of derived classes and friend classes
    protected:
    
    // Implementation (mostly data members)
    // Accessible only by members functions of this class
    private:
};
c 1 0 41 0 0 0 17 0 41 17:// Concrete class
// Replace class_name with the class name
class class_name
{
    // Interface functions (a.k.a. methods in some languages)
    public:
        // Constructors should establish invariants (assumptions) for the class
        // Other member functions should ensure that the invariants still hold
        // Default versions of these are automatically generated.
        // However, if the class contains pointers to allocated objects,
        // the default copy and destructor functions may not be correct.
        // Make sure they handle allocated objects correctly.
        // Rule of zero: Define all of these functions or none.
        
        // Default constructor
        // class_name() {}
        // Copy constructor
        // class_name(const class_name &) {}
        // Move constructor
        // class_name(class_name &&) {}
        // Copy assignment
        // class_name & operator=(const class_name &) {}
        // Move assignment
        // class_name & operator=(class_name &&) {}
        // Default destructor
        // ~class_name() {}
        
        // const indicates that func_name() does not modify members,
        // so it can be invoked for const objects
        type func_name const () {};
        
        // func_name2() cannot be invoked for const objects
        type func_name2 () {};
    
    // Accessible by members of derived classes and friend classes
    protected:
    
    // Implementation (mostly data members)
    // Accessible only by members functions of this class
    private:
};
r 1 0 50 0 0 0 26 0 50 16:// Derived class
// This class implements the representation (data members) and some/all of
// the concrete member functions for the base/super class "base_class".
// There should be multiple derived classes for each base class,
// otherwise the base class serves no purpose.

// Replace class_name with the class name
// Replace base_class with the base class from which this is derived
class class_name : public base_class
{
    // Interface functions (a.k.a. methods in some languages)
    public:
        // Constructors should establish invariants (assumptions) for the class
        // Other member functions should ensure that the invariants still hold
        // Default versions of these are automatically generated.
        // However, if the class contains pointers to allocated objects,
        // the default copy and destructor functions may not be correct.
        // Make sure they handle allocated objects correctly.
        // Rule of zero: Define all of these functions or none.
        
        // Default constructor
        // class_name() {}
        // Copy constructor
        // class_name(const class_name &) {}
        // Move constructor
        // class_name(class_name &&) {}
        // Copy assignment
        // class_name & operator=(const class_name &) {}
        // Move assignment
        // class_name & operator=(class_name &&) {}
        // Default destructor
        // ~class_name() {}
        
        // const indicates that func_name() does not modify members,
        // so it can be invoked for const objects
        // override tells the compiler to verify that there is a corresponding
        // virtual function in the base/super class.  Otherwise, a misspelled
        // function name will be assumed to be intentional and valid.
        type func_name const () override {};
        
        // func_name2() cannot be invoked for const objects
        type func_name2 () override {};
    
    // Accessible by members of derived classes and friend classes
    protected:
    
    // Implementation (mostly data members)
    // Accessible only by members functions of this class
    private:
};
a 1 0 29 0 0 0 5 0 29 71:// Abstract class (base/super class with at least one virtual function)
// We cannot create objects of this type.  This class is merely a
// generic interface for multiple derived/sub classes.  It allows us to
// write a single function that takes multiple similar class objects as
// arguments, for example, provided that they have all the same interface
// functions as the base.  This also means that this base class can
// only access such objects via pointers or references.

// Replace class_name with the class name
class class_name
{
    // Interface functions (a.k.a. methods in some languages)
    public:
        // Don't generate copy functions for a base class
        class_name(const class_name &) = delete;
        class_name & operator=(const class_name &) = delete;
        
        // Destructor should free all allocated resources
        ~class_name() {}
        
        // Might be overridden by derived class
        virtual type func() {};
        
        // Pure virtual: MUST be overridden by derived classes
        virtual type func() = 0;    

    // Accessible by members of derived classes and friend classes
    protected:
};
h 2 0 4 0 23 0 0 0 4 12:#ifndef __H_
#define __H_


#endif  // #ifndef __H_